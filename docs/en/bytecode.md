# âš™ï¸ Bytecode Compiler

## What is Bytecode?

**Bytecode** is an intermediate representation between your source code and machine execution. It's a sequence of simple instructions that the Virtual Machine can execute efficiently.

Think of it like assembly language, but designed specifically for your language's VM.

### Why Bytecode?

1. **Simpler than machine code** â€” easier to generate and debug
2. **Portable** â€” runs on any platform with the VM
3. **Optimizable** â€” can be analyzed and improved before execution

---

## ðŸ“Š Instruction Types (OpCodes)

```c
typedef enum {
    OP_SAY,       // Print a value
    OP_KEEP,      // Declare a variable
    OP_ASSIGN,    // Reassign a variable
    OP_BIN_OP,    // Binary operation (+, -, *, /)
    OP_WHEN,      // Conditional with comparison (>, <, ==)
    OP_WHEN_BOOL, // Conditional with boolean/identifier
    OP_END        // End of program
} OpCode;
```

---

## ðŸ—ï¸ Instruction Structure

```c
typedef struct {
    OpCode op;                    // What operation to perform
    char name[MAX_STRING];        // Variable name or condition var
    char operand[MAX_STRING];     // Primary value
    char operand_right[MAX_STRING]; // Secondary value (for comparisons)
    char else_operand[MAX_STRING];  // Else branch value
    JechTokenType bin_op;         // Operator type (>, <, ==, +, -)
    JechTokenType token_type;     // Value type (STRING, NUMBER, etc.)
    JechTokenType cmp_operand_type; // Comparison operand type
    JechTokenType else_token_type;  // Else value type
    int has_else;                 // Flag for else branch
    int line, column;             // Source location for errors
} Instruction;
```

---

## ðŸ”§ Compilation Functions

### `compile_say`

```c
static void compile_say(Bytecode *bc, const JechASTNode *node)
```

Compiles a `say(...)` statement:

```jc
say("Hello!");
```

Becomes:
```text
{ op: OP_SAY, operand: "Hello!", token_type: TOKEN_STRING }
```

---

### `compile_keep`

```c
static void compile_keep(Bytecode *bc, const JechASTNode *node)
```

Compiles a variable declaration:

```jc
keep age = 25;
```

Becomes:
```text
{ op: OP_KEEP, name: "age", operand: "25", token_type: TOKEN_NUMBER }
```

---

### `compile_assign`

```c
static void compile_assign(Bytecode *bc, const JechASTNode *node)
```

Compiles a variable reassignment:

```jc
age = 30;
```

Becomes:
```text
{ op: OP_ASSIGN, name: "age", operand: "30", token_type: TOKEN_NUMBER }
```

---

### `compile_when`

```c
static void compile_when(Bytecode *bc, const JechASTNode *node)
```

Compiles conditional statements. This is the most complex function because it handles multiple cases:

#### Case 1: Comparison condition
```jc
when (age > 18) { say("adult"); } else { say("minor"); }
```

Becomes:
```text
{
    op: OP_WHEN,
    name: "age",           // Variable to compare
    bin_op: TOKEN_GT,      // > operator
    operand: "18",         // Compare against
    operand_right: "adult", // Then-branch value
    has_else: 1,
    else_operand: "minor"  // Else-branch value
}
```

#### Case 2: Boolean/identifier condition
```jc
when (active) { say("yes"); } else { say("no"); }
```

Becomes:
```text
{
    op: OP_WHEN_BOOL,
    name: "active",        // Variable to check
    operand: "yes",        // Then-branch value
    has_else: 1,
    else_operand: "no"     // Else-branch value
}
```

---

## ðŸŽ¯ Main Entry Point

```c
Bytecode _JechBytecode_CompileAll(JechASTNode **roots, int count)
```

Orchestrates the compilation of all AST nodes:

1. **Initialize** empty bytecode structure
2. **Iterate** through AST roots
3. **Dispatch** to appropriate compile function based on node type
4. **Append** `OP_END` instruction
5. **Return** complete bytecode

### Complete Example

Source code:
```jc
keep age = 25;
when (age > 18) {
    say("adult");
}
else {
    say("minor");
}
```

Generated bytecode:
```text
[0] OP_KEEP      name="age", operand="25"
[1] OP_WHEN      name="age", bin_op=GT, operand="18", 
                 operand_right="adult", has_else=1, else_operand="minor"
[2] OP_END
```

---

## ðŸ’¡ Key Concepts for Learners

1. **Linearization** â€” trees become flat instruction sequences
2. **All data is strings** â€” the VM interprets types at runtime
3. **One instruction per statement** â€” keeps execution simple
4. **Metadata matters** â€” token types help the VM make decisions

---

## ðŸ”¬ How Bytecode Connects to Other Stages

```text
Tokens â†’ Parser â†’ AST â†’ Bytecode â†’ VM
                          â†‘
                     You are here
```

The bytecode compiler reads the AST and produces instructions that the VM can execute directly.

---
