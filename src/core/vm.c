#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include "core/vm.h"
#include "errors/error.h"

#define MAX_VARS 64
#define MAX_ARRAYS 32
#define MAX_ARRAY_SIZE 128

/**
 * Variable table for `keep` instruction
 */
typedef struct
{
	char name[MAX_STRING];
	char value[MAX_STRING];
} JechVariable;

/**
 * Array structure
 */
typedef struct
{
	char name[MAX_STRING];
	char elements[MAX_ARRAY_SIZE][MAX_STRING];
	int size;
} JechArray;

static JechVariable variables[MAX_VARS];
static int var_count = 0;

static JechArray arrays[MAX_ARRAYS];
static int array_count = 0;

/**
 * Sets or updates a variable in the runtime environment
 */
void _JechVM_SetVariable(const char *name, const char *value)
{
	for (int i = 0; i < var_count; i++)
	{
		if (strcmp(variables[i].name, name) == 0)
		{
			strncpy(variables[i].value, value, MAX_STRING);
			return;
		}
	}
	if (var_count < MAX_VARS)
	{
		strncpy(variables[var_count].name, name, MAX_STRING);
		strncpy(variables[var_count].value, value, MAX_STRING);
		var_count++;
	}
}

/**
 * Retrieves the value of a variable by name
 */
const char *_JechVM_GetVariable(const char *name)
{
	for (int i = 0; i < var_count; i++)
	{
		if (strcmp(variables[i].name, name) == 0)
		{
			return variables[i].value;
		}
	}
	return NULL;
}

/**
 * Debug function to print all variables in the VM
 */
void _debug_vm_dump_vars()
{
	extern JechVariable variables[];
	extern int var_count;

	for (int i = 0; i < var_count; i++)
	{
		printf("Variable: %s = %s\n", variables[i].name, variables[i].value);
	}
}

/**
 * Checks if a variable exists in the runtime environment
 */
bool variable_exists(const char *name)
{
	for (int i = 0; i < var_count; i++)
	{
		if (strcmp(variables[i].name, name) == 0)
		{
			return true;
		}
	}
	return false;
}

/**
 * Creates a new array in the runtime environment
 */
static void create_array(const char *name)
{
	if (array_count >= MAX_ARRAYS)
	{
		fprintf(stderr, "Runtime Error: Too many arrays\n");
		exit(1);
	}
	strncpy(arrays[array_count].name, name, MAX_STRING);
	arrays[array_count].size = 0;
	array_count++;
}

/**
 * Finds an array by name
 */
static JechArray *find_array(const char *name)
{
	for (int i = 0; i < array_count; i++)
	{
		if (strcmp(arrays[i].name, name) == 0)
		{
			return &arrays[i];
		}
	}
	return NULL;
}

/**
 * Pushes an element to an array
 */
static void array_push(const char *name, const char *value)
{
	JechArray *arr = find_array(name);
	if (!arr)
	{
		fprintf(stderr, "Runtime Error: Array '%s' not found\n", name);
		exit(1);
	}
	if (arr->size >= MAX_ARRAY_SIZE)
	{
		fprintf(stderr, "Runtime Error: Array '%s' is full\n", name);
		exit(1);
	}
	strncpy(arr->elements[arr->size], value, MAX_STRING);
	arr->size++;
}

/**
 * Gets an element from an array by index
 */
static const char *array_get(const char *name, int index)
{
	JechArray *arr = find_array(name);
	if (!arr)
	{
		fprintf(stderr, "Runtime Error: Array '%s' not found\n", name);
		exit(1);
	}
	if (index < 0 || index >= arr->size)
	{
		fprintf(stderr, "Runtime Error: Index %d out of bounds for array '%s' (size: %d)\n", index, name, arr->size);
		exit(1);
	}
	return arr->elements[index];
}

/**
 * Executes the bytecode generated by the compiler
 */
void _JechVM_Execute(const Bytecode *bc)
{
	for (int i = 0; i < bc->count; i++)
	{
		Instruction inst = bc->instructions[i];

		switch (inst.op)
		{
		case OP_ARRAY_NEW:
			create_array(inst.name);
			break;
		case OP_ARRAY_PUSH:
			array_push(inst.name, inst.operand);
			break;
		case OP_SAY_INDEX:
		{
			int index = atoi(inst.operand);
			const char *value = array_get(inst.name, index);
			printf("%s\n", value);
			break;
		}
		case OP_SAY:
			if (inst.token_type == TOKEN_IDENTIFIER)
			{
				const char *value = _JechVM_GetVariable(inst.operand);
				if (value)
					printf("%s\n", value);
				else
					fprintf(stderr, "Runtime error: undefined variable '%s'\n", inst.operand);
			}
			else
			{
				printf("%s\n", inst.operand);
			}
			break;
		case OP_KEEP:
			if (_JechVM_GetVariable(inst.name) != NULL)
			{
				report_runtime_error("Variable already declared", inst.line, inst.column);
				exit(1);
			}
			_JechVM_SetVariable(inst.name, inst.operand);
			break;
		case OP_ASSIGN:
			if (variable_exists(inst.name))
			{
				_JechVM_SetVariable(inst.name, inst.operand);
			}
			else
			{
				report_runtime_error("Cannot assign to undeclared variable", 0, 0);
				exit(1);
			}
			break;
		case OP_BIN_OP:
		{
			const char *left_val = _JechVM_GetVariable(inst.operand);
			if (!left_val)
			{
				fprintf(stderr, "Runtime Error: Undefined variable '%s'\n", inst.operand);
				exit(1);
			}

			double left = atof(left_val);
			double right = atof(inst.operand_right);
			double result = 0;

			switch (inst.bin_op)
			{
			case TOKEN_PLUS:
				result = left + right;
				break;
			case TOKEN_MINUS:
				result = left - right;
				break;
			case TOKEN_STAR:
				result = left * right;
				break;
			case TOKEN_SLASH:
				if (right == 0)
				{
					fprintf(stderr, "Runtime Error: Division by zero\n");
					exit(1);
				}
				result = left / right;
				break;
			default:
				fprintf(stderr, "Runtime Error: Unsupported binary operator\n");
				exit(1);
			}

			char result_str[MAX_STRING];
			snprintf(result_str, sizeof(result_str), "%.2f", result);
			_JechVM_SetVariable(inst.name, result_str);
			break;
		}
		case OP_WHEN:
		{
			// Binary condition: when (x > 10) or when (x == "hello") { ... } else { ... }
			const char *left_val = _JechVM_GetVariable(inst.name);
			if (!left_val)
			{
				fprintf(stderr, "Runtime Error: Undefined variable '%s'\n", inst.name);
				exit(1);
			}

			// Get right operand value (could be literal or variable)
			const char *right_val = inst.operand;
			if (inst.cmp_operand_type == TOKEN_IDENTIFIER)
			{
				right_val = _JechVM_GetVariable(inst.operand);
				if (!right_val)
				{
					fprintf(stderr, "Runtime Error: Undefined variable '%s'\n", inst.operand);
					exit(1);
				}
			}

			bool is_true = false;

			// String comparison for == with strings
			if (inst.cmp_operand_type == TOKEN_STRING || 
			    (inst.cmp_operand_type == TOKEN_IDENTIFIER && inst.bin_op == TOKEN_EQEQ))
			{
				// Use string comparison for == operator
				if (inst.bin_op == TOKEN_EQEQ)
				{
					is_true = (strcmp(left_val, right_val) == 0);
				}
				else if (inst.bin_op == TOKEN_GT)
				{
					is_true = (strcmp(left_val, right_val) > 0);
				}
				else if (inst.bin_op == TOKEN_LT)
				{
					is_true = (strcmp(left_val, right_val) < 0);
				}
			}
			else
			{
				// Numeric comparison
				double left = atof(left_val);
				double right = atof(right_val);

				switch (inst.bin_op)
				{
				case TOKEN_GT:
					is_true = (left > right);
					break;
				case TOKEN_LT:
					is_true = (left < right);
					break;
				case TOKEN_EQEQ:
					is_true = (left == right);
					break;
				default:
					fprintf(stderr, "Runtime Error: Unsupported operator in when.\n");
					exit(1);
				}
			}

			if (is_true)
			{
				if (inst.token_type == TOKEN_IDENTIFIER)
				{
					const char *say_val = _JechVM_GetVariable(inst.operand_right);
					if (say_val)
						printf("%s\n", say_val);
					else
						fprintf(stderr, "Runtime Error: Undefined variable '%s'\n", inst.operand_right);
				}
				else
				{
					printf("%s\n", inst.operand_right);
				}
			}
			else if (inst.has_else)
			{
				if (inst.else_token_type == TOKEN_IDENTIFIER)
				{
					const char *say_val = _JechVM_GetVariable(inst.else_operand);
					if (say_val)
						printf("%s\n", say_val);
					else
						fprintf(stderr, "Runtime Error: Undefined variable '%s'\n", inst.else_operand);
				}
				else
				{
					printf("%s\n", inst.else_operand);
				}
			}
			break;
		}
		case OP_WHEN_BOOL:
		{
			// Boolean/identifier condition: when (name) { ... } else { ... }
			bool is_true = false;

			if (inst.bin_op == TOKEN_BOOL)
			{
				// Literal true/false
				is_true = strcmp(inst.name, "true") == 0;
			}
			else
			{
				// Identifier - get variable value at runtime
				const char *var_val = _JechVM_GetVariable(inst.name);
				if (!var_val)
				{
					fprintf(stderr, "Runtime Error: Undefined variable '%s'\n", inst.name);
					exit(1);
				}
				is_true = strcmp(var_val, "true") == 0;
			}

			if (is_true)
			{
				if (inst.token_type == TOKEN_IDENTIFIER)
				{
					const char *say_val = _JechVM_GetVariable(inst.operand);
					if (say_val)
						printf("%s\n", say_val);
					else
						fprintf(stderr, "Runtime Error: Undefined variable '%s'\n", inst.operand);
				}
				else
				{
					printf("%s\n", inst.operand);
				}
			}
			else if (inst.has_else)
			{
				if (inst.else_token_type == TOKEN_IDENTIFIER)
				{
					const char *say_val = _JechVM_GetVariable(inst.else_operand);
					if (say_val)
						printf("%s\n", say_val);
					else
						fprintf(stderr, "Runtime Error: Undefined variable '%s'\n", inst.else_operand);
				}
				else
				{
					printf("%s\n", inst.else_operand);
				}
			}
			break;
		}
		case OP_END:
			return;
		default:
			fprintf(stderr, "VM error: unknown opcode %d\n", inst.op);
			return;
		}
	}
}
